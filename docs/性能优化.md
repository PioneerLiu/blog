# 页面请求过程

+   prepare for unload
+   redirect: 重定向
+   app cache: 查询缓存
+   queue: 排队
+   stall: 未知
+   dns: 执行 DNS 查询所用的时间。 页面上的每一个新域都需要完整的往返才能执行 DNS 查询。
+   tcp / ssl (Proxy negotiation): 建立连接所用的时间，包括 TCP 握手/重试和协商 SSL 的时间。
+   send request: 发出网络请求所用的时间。 通常不到一毫秒。
+   ServiceWorker Preparation. The browser is starting up the service worker.
+   Request to ServiceWorker. The request is being sent to the service worker.
+   wating first byte: 首字节返回
+   content download: 资源加载耗时
+   processing: 页面处理
+   Receiving Push. The browser is receiving data for this response via HTTP/2 Server Push.
+   Reading Push. The browser is reading the local data previously received.

# 探测页面性能状态

pagespeed 插件：

https://chrome.google.com/webstore/detail/pagespeed-insights-with-p/lanlbpjbalfkflkhegagflkgcfklnbnh?hl=zh-CN

# 每个阶段的优化点

## prepare for unload

跳过

## redirect

+   资源路径不添加协议
+   检查资源的重定向情况

## app cache

+   稳定的静态资源路径不变，以利用缓存
+   预加载资源
+   `Cache-Control` || `Expires`
+   `Last-Modified` || `Etag`
+   `If-Modified-Since` `If-None-Match`

## queue

+   排队的时间花费。如果某个请求正在排队，则指示：

    +   请求已被渲染引擎推迟，因为该请求的优先级被视为低于关键资源（例如脚本/样式）的优先级。 图像经常发生这种情况。
    +   请求已被暂停，以等待将要释放的不可用 TCP 套接字。
    +   请求已被暂停，因为在 HTTP 1 上，浏览器仅允许每个源拥有六个 TCP 连接。
    +   生成磁盘缓存条目所用的时间（通常非常迅速）
    +   服务器不可用

+   优化方法

    +   减少请求数量
        
        HTTP/1.1 协议下，如 chrome 同域名资源最多 6 个，避免在单个网域检索太多的资源。

        该方案对 HTTP/2 无效，因为 HTTP/2 可以单个 TCP 连接多路复用。

        +   多路复用（spdy / HTTP2）
        +   使用雪碧图

    +   提高资源优先级

## stall

优化方案同 queue

## dns 解析

+   `pre-fetch`

## tcp / ssl 建连

跳过

## send request

+   减少请求大小
    +   压缩 header 头
    +   去除巨型 cookie

## first byte

首字节返回时间（TTFB）。

+   该环节耗时较长的主要原因：

    +   客户端与服务器之间的网络条件较差 

        要解决长 TTFB，首先请尽可能缩减网络。理想的情况是将应用托管在本地，然后查看 TTFB 是否仍然很长。

    +   服务器应用的响应慢

        需要优化应用的响应速度。可以是优化数据库查询、为特定部分的内容实现缓存，或者修改您的网络服务器配置。

        很多原因都可能导致后端缓慢。

    如果本地托管后 TTFB 仍然漫长，那么问题出在您的客户端与服务器之间的网络上。很多事情都可以阻止网络遍历。客户端与服务器之间有许多点，每个点都有其自己的连接限制并可能引发问题。测试时间是否缩短的最简单方法是将您的应用置于其他主机上，并查看 TTFB 是否有所改善。

+   优化

    +   使用 cdn


## content download

如果该阶段耗时较长。

+   减少发送的字节数
    +   使用 webp

        webp 是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8。根据 Google 官方的数据，无损压缩后的 webp 比 PNG 文件少了 26% 的文件大小，有损压缩在具有同等 SSIM 索引的情况下 webp 比 jpeg 文件少 25~34% 的文件大小。webp 支持无损透明度（也叫作 alpha 通道），图片大小增加 22%。支持动画格式 Animated WebP。

    +   根据网络的不同，可以显示不同质量的商品图片
    +   使用 iconfont

        iconfont 对于前端来说有很多优点：自由变化大小、矢量不失真、自由修改颜色、可以添加一些视觉效果如阴影、旋转、透明度、兼容 IE6.

        为了节省流量，在移动端，目前只引用 ttf 一个字体文件，可以考虑 base64 在 css 文件中。

    +   雪碧图注意

        +   解码内存消耗

            内存消耗公式：w * h * 4（宽 * 高 * 每个像素 4 个字节）

            如果设备 DPI 大于 1，还需要乘以 DIP 系数，如 Retina 设备 X4，RetinaHD 设备 X8

        +   禁止生成大图且利用率少

+   range request/response

## processing

+   页面的处理过程：https://developers.google.com/web/fundamentals/performance/critical-rendering-path/?hl=zh-cn

+   js / css 加载和执行顺序

    参考资料：http://www.alloyteam.com/2016/01/points-about-resource-loading/

    +   关于加载顺序就三个根本原因：
        +   js 有可能会修改DOM；
        +   js 的执行有可能依赖最新样式；
        +   现代浏览器有并行加载和 prefetch 的优化
    +   资源并行加载、串行执行
    +   css 会阻塞 js 的执行，因此 css 必须放在 js 脚本之前或内联
    +   动态加载的 js 的执行是不会受到 htm l后面外联的 js 的阻塞的影响，即是说，它的执行和后面 js 的执行顺序是不确定的
    +   `domContentLoaded` 事件除了包含 DOM，还包括 script 标签，且包括 script 的执行时间

+   cpu 负责 Layout，gpu 负责 Paint
+   60 fps 和 设备刷新率

    如今大部分设备的屏幕刷新率都是 60 次/秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滑动页面，那么浏览器渲染动画或页面的每一帧的速率，也需要和设备屏幕的刷新率保持一致。

    也就是说，浏览器对每一帧画面的渲染工作需要在 16 毫秒内完成。但实际上，在渲染某一帧画面的同事，浏览器还有一些额外的工作要做（比如渲染队列的管理，渲染线程与其他线程之间的切换等等）。因此单纯的渲染工作一般需要控制在 10 毫秒之内完成，才能达到流畅的视觉效果。如果超过了这个时间限度，页面的渲染就会出现卡顿，也就是常说的 jank。

+   webp 与 base64

    +   webp 解码是由 GPU 完成，会增加解码开销，但没有太大影响，应该优先使用
    +   DataUrl 解码是在主进程进行的。 会大幅增加图片解码的开销，增加对 CPU 和 内存的开销，甚至阻塞浏览器的主进程，造成卡顿，只有图片的体积足够小，而且是静态的，不值得消耗一个请求的时候，才应该使用 DataUrl。
    
+   图片大小对内存的影响

    +   加载、显示、隐藏、移除
    +   真正耗费内存的是图片的解析过程
    +   隐藏图片节点可以减少内存消耗，但作用不大
    +   移除图片节点不会直接减少内存消耗
    +   图片显示尺寸直接影响内存，显示越大占用内存越多。
    +   同一个页面中完全相同的图片会共享内存。

+   Script - Style - Layout - Paint - Composite

    +   几种情况

        +   JavaScript -- Style -- Layout -- Paint -- Composite

        +   JavaScript -- Style -- （Layout） -- Paint -- Composite

            如果修改了一个 DOM 元素的 paint only 属性，比如背景图片、文字颜色或阴影等，这些属性不会影响页面的布局，因此浏览器会在完成样式计算之后，跳过布局过程，只做绘制渲染层合并过程。

        +   JavaScript -- Style -- （Layout -- Paint） -- Composite

            如果修改一个非样式且非绘制的 css 属性，那么浏览器会在完成样式计算后，跳过布局和绘制的过程，直接做渲染层合并，

            这种方式在性能上是最理想的，对于动画和滚动这种负荷很重的渲染，我们要争取使用这种渲染流程。

    +   优化

        +   Script 优化

            错误的执行时机和太长的时间消耗，是常见的导致 js 性能低下的原因。尽量从这两方面对 js 代码带来的执行性能的影响入手。

            +   减少错误的执行时机

                +   实现动画效果，避免使用 `setTimeout` 或 `setInterval`，请使用 `requestAnimationFrame`
                +   把 DOM 元素的更新划分为多个小任务，分别在多个 frame 中去完成

            +   减少时间消耗

                +   用原生 js 书写首屏代码
                +   监控类代码放到页面底部，不要阻塞页面渲染
                +   降低代码复杂度或把耗时长的 js 代码放到 Web Workers 去做

        +   Style 优化
            +   降低样式选择器的复杂度
            +   使用基于 class 的方式，比如 BEM
            +   减少需要执行样式计算的元素个数
            +   通过 class 或 cssText 的方式批量修改样式
        +   Layout 优化

            +   触发条件

                +   DOM 元素的“几何属性”的修改

                    比如 width/height/left/top 等，都需要重新计算布局

                +   读取样式属性，强制同步布局

                    如果在读取样式属性之前，修改了容器的样式，那么会强制触发重绘。

            +   优化方案
                +   减少需要 Layout 的 DOM 元素数量
                +   使用 flexbox 替代老的布局模型

                    flexbox 的性能更高。

                +   避免强制同步布局事件的发生

                    我们可以强制浏览器在执行 js 脚本之前先执行布局过程，这就是所谓的强制同步布局。

                    在 js 运行的时候，它能获取到的元素样式属性值都是上一帧画面的，都是旧值。

                    如果在读取 height 属性之前，修改了容器的样式，那么会强制触发重绘。

                    ```js
                    box.classList.addClass('big');
                    console.log(box.offsetHeight);
                    ```

                    为了避免触发不必要的布局过程，应该首先批量读取元素样式属性（浏览器将直接返回上一帧的样式属性值），然后再对样式属性进行写操作。

                    ```js
                    console.log(box.offsetHeight);
                    box.classList.addClass('big');
                    ```

            +   避免快速连续的布局

                这种情况更糟糕，看代码：

                ```js
                for(var i = 0; i < sub.length; i++) {
                    sub[i].style.width = box.offsetWidth + 'px';
                }
                ```

                在下一次循环中读取 box 的属性值时，浏览器必须先使上一次循环中的样式更新操作生效，也就是执行布局过程，然后才能响应本次循环中的样式读取操作，也就意味着，布局过程将在每次循环中发生。

                优化：

                ```js
                var width = box.offsetWidth;
                for(var i = 0; i < sub.length; i++) {
                    sub[i].style.width = width + 'px';
                }
                ```

            +   使用 fragment 操作 DOM
            +   没用的元素而设置为不可见 `visibility: hidden`
            +   减少 DOM 的深度
            +   图片在渲染前指定大小：因为 img 元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流

        +   Paint

            Paint（绘制）其实是生成元素呈现的像素的过程。例如，一个有着灰色背景、有文字的元素，当浏览器 Paint 时，是决定哪些像素填充背景、哪些像素填充文字，然后浏览器将这些像素存入位图（Bitmap）中。

            Paint 是代价最高的一步，因此尽量减少 Paint 的时间，甚至避免 Paint 的发生，对页面性能的提升有很重要的作用。

            +   如何触发

                +   触发 Layout。如几何属性的修改。
                +   改变非几何属性，如：背景、颜色、阴影等，不会触发 Layout，但会触发 Paint。（csstriggers.com）
            
            +   如何优化

                提升元素渲染层为合成层。

                需要注意的是，用 `transform` 和 `opacity` 时，如果元素被提升到了独立的合成层，不会触发 Paint；但如果没有提升，还是会触发。

        +   Composite

            由于重叠的原因，可能随便就能产生大量的合成层，而每个合成层要消耗 CPU 和内存。浏览器考虑到了，于是有了层压缩。但不是万能的，有很多情况下，浏览器是无法进行层压缩的。这些也是我们应该避免的。

            提升为合成层有以下好处：

            +   合成层的位图，会交由 GPU 合成，比 CPU 处理要快。

            +   当需要 repaint 时，只需要 repaint 本身，不会影响到其他层。

            +   对于 transform 和 opacity 效果，不会触发 layout 和 paint。

            +   对于 fixed 的合成层，移动时不会触发 repaint。

            对页面中可能发生大量重排重绘的元素单独触发渲染层，使用 GPU 分担 CPU 压力。但也是对 GPU 有压力的，通常情况下，我们会对动画元素采取硬件加速。
            
            +   用合成层做动画

                优先：will-change

                其次：transform：translateZ(0);

                用 transform 或 opacity 实现动画

                他们仅触发 composite。前提是元素提升为 合成层。

            +   减少绘制区域

            +   防止层爆炸

                解决方案是打破 overlap 的条件，也就是让其他元素不要和合成层元素层叠。

                z-index

# 感知性能

+   使用骨架屏

# 其他

+   关于页面加载过程中的各个事件

    参考资料：https://developers.google.com/web/fundamentals/performance/critical-rendering-path/measure-crp?hl=zh-cn

    +   `domLoading`: 这是整个过程的起始时间戳，浏览器即将开始解析第一批收到的 HTML 文档字节
    +   `domInteractive`: 表示浏览器完成对所有 HTML 的解析并且 DOM 构建完成的时间点。
    +   `domContentLoaded`: 一般表示 DOM 和 CSSOM 均准备就绪，且没有 阻塞解析的 js 的时间点
    +   `domComplete`: 顾名思义，所有处理完成，并且网页上的所有资源（图像等）都已下载完毕，也就是说，加载转环已停止旋转
    +   `loadEvent`: 作为每个网页加载的最后一步，浏览器会触发 onload 事件，以便触发额外的应用逻辑